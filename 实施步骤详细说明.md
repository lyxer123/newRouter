# 双W5500功能实施步骤详细说明

## 步骤1：硬件配置扩展

### 1.1 实现目标
在Kconfig配置系统中添加W5500卡2的GPIO配置项，支持独立配置卡2的CS、INT、RST引脚。

### 1.2 具体实现
**文件**：`managed_components/espressif__iot_bridge/Kconfig`

**修改内容**：
在`BRIDGE_USE_SPI_ETHERNET`配置块中，添加卡2的配置项：

```kconfig
config BRIDGE_ETH_SPI_CS1_GPIO
    int "SPI CS1 GPIO number for SPI Ethernet module #2"
    range BRIDGE_GPIO_RANGE_MIN BRIDGE_GPIO_RANGE_MAX
    default 9 if IDF_TARGET_ESP32S2 || IDF_TARGET_ESP32S3
    default 3 if IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32C2
    help
        Set the GPIO number used by SPI CS1, i.e. Chip Select for the second W5500 module.

config BRIDGE_ETH_SPI_INT1_GPIO
    int "Interrupt GPIO number SPI Ethernet module #2"
    range BRIDGE_GPIO_RANGE_MIN BRIDGE_GPIO_RANGE_MAX
    default 14 if IDF_TARGET_ESP32S2 || IDF_TARGET_ESP32S3
    default 5 if IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32C2
    help
        Set the GPIO number used by the second SPI Ethernet module interrupt line.

config BRIDGE_ETH_SPI_PHY_RST1_GPIO
    int "PHY Reset GPIO number of SPI Ethernet Module #2"
    range -1 BRIDGE_GPIO_RANGE_MAX
    default -1
    help
        Set the GPIO number used to reset PHY chip on the second SPI Ethernet module.
        Set to -1 to disable PHY chip hardware reset.

config BRIDGE_ETH_SPI_PHY_ADDR1
    int "PHY Address of SPI Ethernet Module #2"
    range 0 31
    default 1
    help
        Set the second SPI Ethernet module PHY address according your board schematic.
```

### 1.3 检验步骤
1. **配置验证**：
   ```bash
   idf.py menuconfig
   ```
   - 导航到：`Component config → Bridge Configuration → ETH Configuration`
   - 验证以下配置项是否存在：
     - `SPI CS1 GPIO number for SPI Ethernet module #2`
     - `Interrupt GPIO number SPI Ethernet module #2`
     - `PHY Reset GPIO number of SPI Ethernet Module #2`
     - `PHY Address of SPI Ethernet Module #2`

2. **配置文件验证**：
   ```bash
   grep -E "BRIDGE_ETH_SPI_(CS1|INT1|PHY_RST1|PHY_ADDR1)" sdkconfig
   ```
   - 验证配置项已保存到sdkconfig文件

3. **编译验证**：
   ```bash
   idf.py build
   ```
   - 检查编译是否成功
   - 检查是否有配置相关的警告

---

## 步骤2：扩展W5500初始化函数

### 2.1 实现目标
修改`bridge_eth.c`，支持初始化第二个W5500设备，确保两个W5500可以共享SPI总线但使用独立的控制信号。

### 2.2 具体实现
**文件**：`managed_components/espressif__iot_bridge/src/bridge_eth.c`

**修改内容**：

1. **修改W5500初始化函数，支持设备索引**：
```c
#if CONFIG_ETH_SPI_ETHERNET_W5500
esp_err_t esp_spi_eth_new_w5500(spi_device_interface_config_t *spi_devcfg, 
                                 esp_netif_t *eth_netif_spi, 
                                 esp_eth_handle_t *eth_handle_spi,
                                 int card_index)  // 新增参数
{
    // ... 现有代码 ...
    
    // 根据card_index选择不同的GPIO
    if (card_index == 0) {
        w5500_config.int_gpio_num = CONFIG_BRIDGE_ETH_SPI_INT0_GPIO;
        phy_config_spi.phy_addr = CONFIG_BRIDGE_ETH_SPI_PHY_ADDR0;
        phy_config_spi.reset_gpio_num = CONFIG_BRIDGE_ETH_SPI_PHY_RST0_GPIO;
    } else if (card_index == 1) {
        w5500_config.int_gpio_num = CONFIG_BRIDGE_ETH_SPI_INT1_GPIO;
        phy_config_spi.phy_addr = CONFIG_BRIDGE_ETH_SPI_PHY_ADDR1;
        phy_config_spi.reset_gpio_num = CONFIG_BRIDGE_ETH_SPI_PHY_RST1_GPIO;
    }
    
    // ... 其余代码保持不变 ...
}
#endif
```

2. **修改SPI初始化函数，支持多个设备**：
```c
esp_err_t esp_bridge_eth_spi_init(esp_netif_t* eth_netif_spi, int card_index)
{
    esp_err_t ret = ESP_FAIL;
    static bool eth_is_start = false;
    static esp_eth_handle_t eth_handle_spi_card0 = NULL;
    static esp_eth_handle_t eth_handle_spi_card1 = NULL;
    esp_eth_handle_t *eth_handle_spi = NULL;
    
    if (card_index == 0) {
        eth_handle_spi = &eth_handle_spi_card0;
    } else if (card_index == 1) {
        eth_handle_spi = &eth_handle_spi_card1;
    } else {
        return ESP_ERR_INVALID_ARG;
    }
    
    if (!eth_is_start) {
        // Install GPIO ISR handler (只初始化一次)
        gpio_install_isr_service(0);
        
        // Init SPI bus (只初始化一次，共享总线)
        spi_bus_config_t buscfg = {
            .miso_io_num = CONFIG_BRIDGE_ETH_SPI_MISO_GPIO,
            .mosi_io_num = CONFIG_BRIDGE_ETH_SPI_MOSI_GPIO,
            .sclk_io_num = CONFIG_BRIDGE_ETH_SPI_SCLK_GPIO,
            .quadwp_io_num = -1,
            .quadhd_io_num = -1,
        };
        ESP_ERROR_CHECK(spi_bus_initialize(CONFIG_BRIDGE_ETH_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));
        eth_is_start = true;
    }
    
    // 为每个设备创建独立的SPI设备配置
    spi_device_interface_config_t devcfg = {
        .mode = 0,
        .clock_speed_hz = CONFIG_BRIDGE_ETH_SPI_CLOCK_MHZ * 1000 * 1000,
        .queue_size = 20,
        .spics_io_num = (card_index == 0) ? CONFIG_BRIDGE_ETH_SPI_CS0_GPIO : CONFIG_BRIDGE_ETH_SPI_CS1_GPIO
    };
    
    // 初始化对应的W5500设备
    uint8_t spi_eth_module_max = sizeof(esp_bridge_spi_eth_module)/sizeof(esp_bridge_spi_eth_module[0]);
    for (uint8_t i = 0; i < spi_eth_module_max; i++) {
        if (esp_bridge_spi_eth_module[i](&devcfg, eth_netif_spi, eth_handle_spi, card_index) == ESP_OK) {
            break;
        }
    }
    
    if (*eth_handle_spi) {
        // 设置MAC地址（每个设备使用不同的MAC）
        uint8_t mac[6] = {0x02, 0x00, 0x00, 0x12, 0x34, 0x56 + card_index};
        ESP_ERROR_CHECK(esp_eth_ioctl(*eth_handle_spi, ETH_CMD_S_MAC_ADDR, mac));
        
        // attach Ethernet driver to TCP/IP stack
        ESP_ERROR_CHECK(esp_netif_attach(eth_netif_spi, esp_eth_new_netif_glue(*eth_handle_spi)));
    }
    
    if (!eth_is_start) {
        ret = esp_eth_start(*eth_handle_spi);
        eth_is_start = true;
    } else {
        ret = esp_eth_start(*eth_handle_spi);
    }
    
    return ret;
}
```

### 2.3 检验步骤
1. **编译验证**：
   ```bash
   idf.py build
   ```
   - 检查是否有编译错误
   - 检查是否有类型不匹配警告

2. **运行时验证**：
   - 查看串口日志，应该看到两个W5500的初始化信息
   - 检查日志中是否有"Ethernet Started"消息（应该出现两次）
   - 检查是否有GPIO配置错误

3. **硬件验证**：
   - 使用示波器检查CS0和CS1信号是否正确切换
   - 检查INT0和INT1信号是否正确连接
   - 检查RST0和RST1信号（如果启用）

---

## 步骤3：创建双网卡网络接口

### 3.1 实现目标
在系统启动时创建两个独立的网络接口，卡1支持自动WAN/LAN切换，卡2固定为LAN。

### 3.2 具体实现
**文件1**：`managed_components/espressif__iot_bridge/src/bridge_eth.c`

**修改`esp_bridge_create_eth_netif`函数**：
```c
esp_netif_t* esp_bridge_create_eth_netif(esp_netif_ip_info_t* ip_info, 
                                          uint8_t mac[6], 
                                          bool data_forwarding, 
                                          bool enable_dhcps,
                                          int card_index)  // 新增参数：0=卡1，1=卡2
{
    esp_netif_ip_info_t netif_ip_info = { 0 };
    esp_netif_inherent_config_t esp_netif_common_config = {
        .get_ip_event = IP_EVENT_ETH_GOT_IP,
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 4, 0)
        .lost_ip_event = IP_EVENT_ETH_LOST_IP,
#endif
        .if_key = "ETH_WAN",
        .if_desc = "eth",
        .flags = (esp_netif_flags_t)(ESP_NETIF_FLAG_GARP | ESP_NETIF_FLAG_EVENT_IP_MODIFIED),
        .route_prio = 50,
    };

    // 卡1：支持自动WAN/LAN切换
    // 卡2：固定为LAN
    if (card_index == 0) {
        // 卡1：启用自动WAN/LAN切换
        // 初始状态不设置data_forwarding，由自动切换逻辑决定
        // 使用默认配置，让自动切换逻辑处理
    } else if (card_index == 1) {
        // 卡2：固定为LAN
        esp_netif_common_config.flags |= ESP_NETIF_DHCP_SERVER;
        esp_netif_common_config.if_key = "ETH_LAN2";
        esp_netif_common_config.route_prio = 10;
        data_forwarding = true;
        enable_dhcps = true;
    }

    if (data_forwarding && card_index != 0) {
        // 卡2固定LAN模式
        esp_netif_common_config.flags |= ESP_NETIF_DHCP_SERVER;
        if (card_index == 1) {
            esp_netif_common_config.if_key = "ETH_LAN2";
        } else {
            esp_netif_common_config.if_key = "ETH_LAN";
        }
        esp_netif_common_config.route_prio = 10;
    } else if (!data_forwarding && card_index == 0) {
        // 卡1作为WAN（由自动切换逻辑管理）
        esp_netif_common_config.flags |= ESP_NETIF_DHCP_CLIENT;
        esp_netif_common_config.if_key = "ETH_WAN";
        esp_netif_common_config.route_prio = 50;
    }

    const esp_netif_driver_ifconfig_t eth_driver_ifconfig = {
        .driver_free_rx_buffer = eth_driver_free_rx_buffer,
        .transmit = eth_io_transmit,
        .transmit_wrap = eth_io_transmit_wrap,
        .handle = (card_index == 0) ? "ETH_CARD1" : "ETH_CARD2"  // 使用不同的handle区分
    };

    esp_bridge_eth_event_handler_register();

    esp_netif_config_t eth_config = ESP_NETIF_DEFAULT_ETH();
    eth_config.driver = &eth_driver_ifconfig;
    eth_config.base = &esp_netif_common_config;

    esp_netif_t* netif = esp_bridge_create_netif(&eth_config, ip_info, mac, enable_dhcps);
    if (netif) {
        // 卡1：使用自动WAN/LAN切换
        if (card_index == 0) {
#if defined(CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN)
            // 卡1启用自动切换，由esp_bridge_set_eth_wan_netif/esp_bridge_set_eth_lan_netif管理
            // 这里不设置固定角色，让自动切换逻辑处理
#endif
        } else {
            // 卡2：固定LAN，不使用自动切换
            // 直接配置为LAN模式
        }
        
        esp_netif_action_stop(netif, NULL, 0, NULL);
#if CONFIG_BRIDGE_USE_INTERNAL_ETHERNET
        esp_bridge_eth_init(netif);
#elif CONFIG_BRIDGE_USE_SPI_ETHERNET
        esp_bridge_eth_spi_init(netif, card_index);
#endif
        esp_netif_up(netif);

        ESP_LOGI(TAG, "[%-12s] Card%d", esp_netif_get_ifkey(netif), card_index);

        if (data_forwarding) {
            esp_bridge_netif_list_add(netif, eth_netif_dhcp_status_change_cb);
            esp_netif_get_ip_info(netif, &netif_ip_info);
            ESP_LOGI(TAG, "ETH Card%d IP Address:" IPSTR, card_index, IP2STR(&netif_ip_info.ip));
            ip_napt_enable(netif_ip_info.ip.addr, 1);
        } else {
            esp_bridge_netif_list_add(netif, NULL);
        }

        if (enable_dhcps) {
            esp_netif_dhcps_start(netif);
        }
    }

    return netif;
}
```

**文件2**：`managed_components/espressif__iot_bridge/src/bridge_common.c`

**修改`esp_bridge_create_all_netif`函数**：
```c
void esp_bridge_create_all_netif(void)
{
    ESP_LOGI(TAG, "esp-iot-bridge version: %d.%d.%d", IOT_BRIDGE_VER_MAJOR, IOT_BRIDGE_VER_MINOR, IOT_BRIDGE_VER_PATCH);

    // ... 现有的WiFi、USB等接口创建代码 ...

    // 创建W5500卡1（支持自动WAN/LAN切换）
    #if defined(CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN)
        // 卡1使用自动切换功能，创建时不确定角色
        // 由自动切换逻辑根据连接设备决定
        esp_bridge_create_eth_netif(NULL, NULL, false, false, 0);  // card_index = 0
    #elif defined(CONFIG_BRIDGE_EXTERNAL_NETIF_ETHERNET)
        // 如果未启用自动切换，卡1作为WAN
        esp_bridge_create_eth_netif(NULL, NULL, false, false, 0);
    #endif

    // 创建W5500卡2（固定LAN模式）
    #if defined(CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET)
        // 卡2固定为LAN，始终启用DHCP服务器
        esp_bridge_create_eth_netif(NULL, NULL, true, true, 1);  // card_index = 1
    #endif

    // ... 4G模块等其余代码 ...
}
```

**文件3**：`sdkconfig.defaults`

**确保配置正确**：
```ini
# 启用自动WAN/LAN切换（仅用于卡1）
CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN=y

# 启用以太网接口
CONFIG_BRIDGE_ETHERNET_NETIF_ENABLE=y

# 卡2固定作为LAN
CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET=y

# 4G转WiFi保持不变
CONFIG_BRIDGE_EXTERNAL_NETIF_MODEM=y
CONFIG_BRIDGE_DATA_FORWARDING_NETIF_SOFTAP=y
```

### 3.3 检验步骤
1. **日志验证**：
   - 启动后查看串口日志
   - 应该看到两个以太网接口的创建信息
   - 检查接口名称：`ETH_WAN`和`ETH_LAN2`

2. **接口状态验证**：
   ```bash
   # 在ESP32上使用日志输出，或在主机上使用网络工具
   # 检查接口列表
   ```
   - 卡1应该显示为DHCP客户端模式
   - 卡2应该显示为DHCP服务器模式

3. **IP地址验证**：
   - 卡1连接到路由器后，应该自动获取IP地址
   - 卡2应该配置为静态IP（例如192.168.4.1）

4. **DHCP服务器验证**：
   - 将计算机连接到卡2
   - 检查计算机是否自动获取IP地址
   - 验证IP地址在正确的网段（例如192.168.4.x）

---

## 步骤4：实现网络状态监控

### 4.1 实现目标
监控卡1和卡2的网络连接状态，包括链路状态、IP地址获取状态，以及卡1的角色（WAN/LAN）。

### 4.2 具体实现
**文件**：`managed_components/espressif__iot_bridge/src/bridge_eth.c`

**添加网络状态管理结构**：
```c
typedef enum {
    ETH_ROLE_UNKNOWN = 0,
    ETH_ROLE_WAN,
    ETH_ROLE_LAN
} eth_role_t;

typedef struct {
    bool card1_connected;      // 卡1链路连接状态
    eth_role_t card1_role;     // 卡1当前角色（WAN/LAN）
    bool card1_got_ip;         // 卡1是否获取到IP
    esp_ip4_addr_t card1_ip;   // 卡1的IP地址
    esp_ip4_addr_t card1_gw;   // 卡1的网关地址（WAN模式）
    bool card2_connected;      // 卡2链路连接状态（固定LAN）
    bool card2_got_ip;         // 卡2是否获取到IP
    esp_ip4_addr_t card2_ip;   // 卡2的IP地址
    bool modem_connected;      // 4G连接状态
    esp_ip4_addr_t modem_ip;   // 4G的IP地址
} network_status_t;

static network_status_t g_network_status = {0};
```

**修改事件处理函数**：
```c
static void eth_event_handler(void *arg, esp_event_base_t event_base,
                              int32_t event_id, void *event_data)
{
    uint8_t mac_addr[6] = {0};
    esp_eth_handle_t eth_handle = *(esp_eth_handle_t *)event_data;
    
    // 判断是哪个网卡的事件
    esp_netif_t *netif_wan = esp_netif_get_handle_from_ifkey("ETH_WAN");
    esp_netif_t *netif_lan = esp_netif_get_handle_from_ifkey("ETH_LAN");
    esp_netif_t *netif_lan2 = esp_netif_get_handle_from_ifkey("ETH_LAN2");
    
    bool is_card1 = false;
    bool is_card2 = false;
    
    if (netif_wan && esp_netif_get_io_driver(netif_wan) == eth_handle) {
        is_card1 = true;
    } else if (netif_lan && esp_netif_get_io_driver(netif_lan) == eth_handle) {
        is_card1 = true;
    } else if (netif_lan2 && esp_netif_get_io_driver(netif_lan2) == eth_handle) {
        is_card2 = true;
    }
    
    switch (event_id) {
    case ETHERNET_EVENT_CONNECTED:
        esp_eth_ioctl(eth_handle, ETH_CMD_G_MAC_ADDR, mac_addr);
        if (is_card1) {
            g_network_status.card1_connected = true;
            ESP_LOGI(TAG, "W5500 Card1 Link Up");
        } else if (is_card2) {
            g_network_status.card2_connected = true;
            ESP_LOGI(TAG, "W5500 Card2 Link Up");
        }
        ESP_LOGI(TAG, "Ethernet HW Addr "MACSTR"", MAC2STR(mac_addr));
        break;
        
    case ETHERNET_EVENT_DISCONNECTED:
        if (is_card1) {
            g_network_status.card1_connected = false;
            g_network_status.card1_got_ip = false;
            g_network_status.card1_role = ETH_ROLE_UNKNOWN;
            ESP_LOGI(TAG, "W5500 Card1 Link Down");
        } else if (is_card2) {
            g_network_status.card2_connected = false;
            g_network_status.card2_got_ip = false;
            ESP_LOGI(TAG, "W5500 Card2 Link Down");
        }
        IOT_BRIDGE_NAPT_TABLE_CLEAR();
        break;
        
    // ... 其他事件 ...
    }
}

static void got_ip_event_handler(void *arg, esp_event_base_t event_base,
                                 int32_t event_id, void *event_data)
{
    ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;
    const esp_netif_ip_info_t *ip_info = &event->ip_info;
    const char *if_key = esp_netif_get_ifkey(event->esp_netif);
    
    if (strcmp(if_key, "ETH_WAN") == 0) {
        // 卡1获取到IP，作为WAN
        g_network_status.card1_got_ip = true;
        g_network_status.card1_role = ETH_ROLE_WAN;
        g_network_status.card1_ip = ip_info->ip;
        g_network_status.card1_gw = ip_info->gw;
        ESP_LOGI(TAG, "W5500 Card1 Got IP (WAN): " IPSTR, IP2STR(&ip_info->ip));
        ESP_LOGI(TAG, "W5500 Card1 Gateway: " IPSTR, IP2STR(&ip_info->gw));
        
        // 更新路由优先级
        update_route_priority();
    } else if (strcmp(if_key, "ETH_LAN") == 0) {
        // 卡1分配IP，作为LAN
        g_network_status.card1_got_ip = true;
        g_network_status.card1_role = ETH_ROLE_LAN;
        g_network_status.card1_ip = ip_info->ip;
        ESP_LOGI(TAG, "W5500 Card1 Assigned IP (LAN): " IPSTR, IP2STR(&ip_info->ip));
        
        // 更新路由优先级
        update_route_priority();
    } else if (strcmp(if_key, "ETH_LAN2") == 0) {
        // 卡2获取到IP（固定LAN）
        g_network_status.card2_got_ip = true;
        g_network_status.card2_ip = ip_info->ip;
        ESP_LOGI(TAG, "W5500 Card2 IP: " IPSTR, IP2STR(&ip_info->ip));
    }
}

static void lost_ip_event_handler(void *arg, esp_event_base_t event_base,
                                  int32_t event_id, void *event_data)
{
    ip_event_lost_ip_t *event = (ip_event_lost_ip_t *) event_data;
    const char *if_key = esp_netif_get_ifkey(event->esp_netif);
    
    if (strcmp(if_key, "ETH_WAN") == 0 || strcmp(if_key, "ETH_LAN") == 0) {
        // 卡1丢失IP
        g_network_status.card1_got_ip = false;
        g_network_status.card1_role = ETH_ROLE_UNKNOWN;
        ESP_LOGI(TAG, "W5500 Card1 Lost IP");
        
        // 更新路由优先级
        update_route_priority();
    } else if (strcmp(if_key, "ETH_LAN2") == 0) {
        // 卡2丢失IP
        g_network_status.card2_got_ip = false;
        ESP_LOGI(TAG, "W5500 Card2 Lost IP");
    }
}
```

**注册事件处理函数**：
```c
void esp_bridge_eth_event_handler_register(void)
{
    static bool event_handlers_registered = false;
    
    if (!event_handlers_registered) {
        ESP_ERROR_CHECK(esp_event_handler_register(ETH_EVENT, ESP_EVENT_ANY_ID, &eth_event_handler, NULL));
        ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_ETH_GOT_IP, &got_ip_event_handler, NULL));
        ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_ETH_LOST_IP, &lost_ip_event_handler, NULL));
        event_handlers_registered = true;
    }
}
```

### 4.3 检验步骤
1. **连接测试**：
   - 将卡1连接到路由器
   - 观察日志，应该看到"W5500 Card1 Link Up"
   - 观察日志，应该看到"W5500 Card1 Got IP"

2. **断开测试**：
   - 断开卡1网线
   - 观察日志，应该看到"W5500 Card1 Link Down"
   - 观察日志，应该看到"W5500 Card1 Lost IP"

3. **状态验证**：
   - 添加日志输出，显示当前网络状态
   - 验证`g_network_status`结构体的值是否正确

---

## 步骤5：实现智能路由切换

### 5.1 实现目标
根据卡1的角色（WAN/LAN）和网络状态，动态调整路由优先级，实现智能路由策略。

### 5.2 具体实现
**文件**：`managed_components/espressif__iot_bridge/src/bridge_common.c`

**添加路由优先级更新函数**：
```c
void update_route_priority(void)
{
    extern network_status_t g_network_status;
    
    esp_netif_t *eth_wan_netif = esp_netif_get_handle_from_ifkey("ETH_WAN");
    esp_netif_t *eth_lan_netif = esp_netif_get_handle_from_ifkey("ETH_LAN");
    esp_netif_t *eth_lan2_netif = esp_netif_get_handle_from_ifkey("ETH_LAN2");
    esp_netif_t *modem_netif = esp_netif_get_handle_from_ifkey("PPP");
    
    if (!modem_netif) {
        return;
    }
    
    // 卡2始终为LAN，优先级固定为10
    if (eth_lan2_netif) {
        esp_netif_set_route_prio(eth_lan2_netif, 10);
    }
    
    // 根据卡1的角色调整路由优先级
    if (g_network_status.card1_role == ETH_ROLE_WAN) {
        // 卡1作为WAN
        if (eth_wan_netif && g_network_status.card1_connected && g_network_status.card1_got_ip) {
            // 卡1可用，设置高优先级
            esp_netif_set_route_prio(eth_wan_netif, 50);
            esp_netif_set_route_prio(modem_netif, 30);  // 4G作为备用
            ESP_LOGI(TAG, "Route priority: Card1(WAN) (50) > 4G (30) > Card2(LAN) (10)");
        } else {
            // 卡1不可用，使用4G
            if (eth_wan_netif) {
                esp_netif_set_route_prio(eth_wan_netif, 10);
            }
            esp_netif_set_route_prio(modem_netif, 50);   // 提升4G优先级
            ESP_LOGI(TAG, "Route priority: 4G (50) > Card1(WAN) (10) > Card2(LAN) (10)");
        }
    } else if (g_network_status.card1_role == ETH_ROLE_LAN) {
        // 卡1作为LAN
        if (eth_lan_netif) {
            esp_netif_set_route_prio(eth_lan_netif, 10);  // 卡1作为LAN，低优先级
        }
        
        if (g_network_status.modem_connected) {
            // 4G可用，设置高优先级
            esp_netif_set_route_prio(modem_netif, 50);
            ESP_LOGI(TAG, "Route priority: 4G (50) > Card1(LAN) (10) > Card2(LAN) (10)");
        } else {
            // 4G不可用，仅使用LAN接口
            esp_netif_set_route_prio(modem_netif, 10);
            ESP_LOGI(TAG, "Route priority: Card1(LAN) (10) = Card2(LAN) (10), 4G unavailable");
        }
    } else {
        // 卡1角色未知，等待角色确定
        ESP_LOGI(TAG, "Card1 role unknown, waiting for role determination");
    }
}

// 检查卡1当前角色
eth_role_t check_eth1_role(void)
{
    extern network_status_t g_network_status;
    
    esp_netif_t *eth_wan_netif = esp_netif_get_handle_from_ifkey("ETH_WAN");
    esp_netif_t *eth_lan_netif = esp_netif_get_handle_from_ifkey("ETH_LAN");
    
    if (eth_wan_netif && esp_netif_is_up(eth_wan_netif)) {
        esp_netif_ip_info_t ip_info;
        if (esp_netif_get_ip_info(eth_wan_netif, &ip_info) == ESP_OK && 
            ip_info.ip.addr != 0) {
            return ETH_ROLE_WAN;
        }
    }
    
    if (eth_lan_netif && esp_netif_is_up(eth_lan_netif)) {
        esp_netif_ip_info_t ip_info;
        if (esp_netif_get_ip_info(eth_lan_netif, &ip_info) == ESP_OK && 
            ip_info.ip.addr != 0) {
            return ETH_ROLE_LAN;
        }
    }
    
    return ETH_ROLE_UNKNOWN;
}

// 检查卡1的网络连通性
bool check_eth1_connectivity(void)
{
    extern network_status_t g_network_status;
    
    if (!g_network_status.card1_connected || !g_network_status.card1_got_ip) {
        return false;
    }
    
    // 可以添加ping网关的测试
    // 这里简化处理，仅检查IP状态
    return true;
}

// 周期性检查网络状态的任务
static void network_monitor_task(void *pvParameters)
{
    const TickType_t xDelay = pdMS_TO_TICKS(5000);  // 5秒检查一次
    
    while (1) {
        // 检查卡1状态
        bool card1_available = check_eth1_connectivity();
        
        // 更新路由优先级
        update_route_priority();
        
        // 更新DNS信息
        esp_netif_t *external_netif = NULL;
        if (card1_available) {
            external_netif = esp_netif_get_handle_from_ifkey("ETH_WAN");
        } else {
            external_netif = esp_netif_get_handle_from_ifkey("PPP");
        }
        if (external_netif) {
            esp_bridge_update_dns_info(external_netif, NULL);
        }
        
        vTaskDelay(xDelay);
    }
}

// 启动网络监控任务
void esp_bridge_start_network_monitor(void)
{
    xTaskCreate(network_monitor_task, "net_monitor", 4096, NULL, 5, NULL);
}
```

**在`esp_bridge_create_all_netif`中启动监控**：
```c
void esp_bridge_create_all_netif(void)
{
    // ... 创建所有网络接口 ...
    
    // 启动网络监控任务
    esp_bridge_start_network_monitor();
}
```

### 5.3 检验步骤
1. **路由优先级测试**：
   - 同时连接卡1和4G
   - 检查路由表，验证卡1的优先级高于4G
   - 使用`traceroute`或类似工具测试数据包路径

2. **自动切换测试**：
   - 连接卡1和4G，验证流量走卡1
   - 断开卡1网线，验证流量自动切换到4G
   - 重新连接卡1，验证流量自动切回卡1

3. **延迟测试**：
   - 测量切换延迟时间
   - 验证切换过程中数据包的丢失情况

4. **稳定性测试**：
   - 频繁插拔卡1网线
   - 验证系统是否能稳定切换

---

## 步骤6：配置DHCP服务器（卡2）

### 6.1 实现目标
确保卡2正确配置DHCP服务器，为下位计算机分配IP地址。

### 6.2 具体实现
**文件**：`managed_components/espressif__iot_bridge/src/bridge_common.c`

**DHCP服务器配置已经在`esp_bridge_create_netif`中实现，需要确保**：
1. 卡2的网络接口启用DHCP服务器
2. IP地址池配置正确
3. DNS服务器地址正确更新

**修改DNS更新逻辑**：
```c
esp_err_t esp_bridge_update_dns_info(esp_netif_t *external_netif, esp_netif_t *data_forwarding_netif)
{
    esp_netif_dns_info_t dns_info = {0};
    if (external_netif) {
        esp_netif_get_dns_info(external_netif, ESP_NETIF_DNS_MAIN, &dns_info);
    }
    if (dns_info.ip.u_addr.ip4.addr == 0) {
        dns_info.ip.u_addr.ip4.addr = ipaddr_addr(CONFIG_BRIDGE_STATIC_DNS_SERVER_MAIN);
        dns_info.ip.type = IPADDR_TYPE_V4;
    }

    if (data_forwarding_netif) {
        esp_bridge_update_data_forwarding_netif_dns_info(data_forwarding_netif, &dns_info);
    } else {
        // 更新所有数据转发接口的DNS
        #if defined(CONFIG_BRIDGE_DATA_FORWARDING_NETIF_SOFTAP)
            esp_bridge_update_data_forwarding_netif_dns_info(esp_netif_get_handle_from_ifkey("WIFI_AP_DEF"), &dns_info);
        #endif
        #if defined(CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET)
            // 更新卡2的DNS
            esp_netif_t *eth_lan2 = esp_netif_get_handle_from_ifkey("ETH_LAN2");
            if (eth_lan2) {
                esp_bridge_update_data_forwarding_netif_dns_info(eth_lan2, &dns_info);
            }
        #endif
    }
    return ESP_OK;
}
```

### 6.3 检验步骤
1. **DHCP服务器测试**：
   - 将计算机连接到卡2
   - 检查计算机是否自动获取IP地址
   - 验证IP地址在192.168.4.x网段（或配置的其他网段）

2. **DNS测试**：
   - 在计算机上执行`nslookup www.baidu.com`
   - 验证DNS解析是否正常

3. **网关测试**：
   - 在计算机上执行`ipconfig`（Windows）或`ifconfig`（Linux）
   - 验证网关地址为卡2的IP地址

4. **上网测试**：
   - 在计算机上访问网页
   - 验证能否正常上网
   - 验证流量是否通过卡1或4G转发

---

## 步骤7：配置自动WAN/LAN切换（仅卡1）

### 7.1 实现目标
确保卡1支持自动WAN/LAN切换，卡2固定为LAN，不会参与自动切换。

### 7.2 具体实现
**文件1**：`sdkconfig.defaults`

```ini
# 启用自动WAN/LAN切换（仅用于卡1）
CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN=y

# 启用以太网接口
CONFIG_BRIDGE_ETHERNET_NETIF_ENABLE=y

# 卡2固定作为LAN
CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET=y

# 4G转WiFi保持不变
CONFIG_BRIDGE_EXTERNAL_NETIF_MODEM=y
CONFIG_BRIDGE_DATA_FORWARDING_NETIF_SOFTAP=y
```

**文件2**：`managed_components/espressif__iot_bridge/src/bridge_eth.c`

**确保卡1使用自动切换，卡2不使用**：
```c
esp_netif_t* esp_bridge_create_eth_netif(esp_netif_ip_info_t* ip_info, 
                                          uint8_t mac[6], 
                                          bool data_forwarding, 
                                          bool enable_dhcps,
                                          int card_index)
{
    // ... 现有代码 ...
    
    if (netif) {
        // 卡1：使用自动WAN/LAN切换
        if (card_index == 0) {
#if defined(CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN)
            // 卡1启用自动切换
            // 由esp_bridge_set_eth_wan_netif和esp_bridge_set_eth_lan_netif管理
            // 初始状态不设置，等待自动切换逻辑决定
            ESP_LOGI(TAG, "Card1: Auto WAN/LAN switching enabled");
#else
            // 如果未启用自动切换，卡1固定为WAN
            if (data_forwarding) {
                esp_bridge_set_eth_lan_netif(netif);
            } else {
                esp_bridge_set_eth_wan_netif(netif);
            }
#endif
        } else {
            // 卡2：固定LAN，不使用自动切换
            ESP_LOGI(TAG, "Card2: Fixed LAN mode");
            // 卡2已经在上面配置为固定LAN，这里不需要额外处理
        }
        
        // ... 其余代码 ...
    }
    
    return netif;
}
```

**添加配置验证**：
```c
void esp_bridge_validate_config(void)
{
#if !defined(CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN)
    ESP_LOGW(TAG, "CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN is disabled, Card1 will not auto-switch");
#else
    ESP_LOGI(TAG, "Card1: Auto WAN/LAN switching enabled");
    ESP_LOGI(TAG, "Card2: Fixed LAN mode");
#endif

#if !defined(CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET)
    ESP_LOGE(TAG, "CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET must be enabled for Card2!");
    assert(0);
#endif
}
```

**在`esp_bridge_create_all_netif`中调用验证**：
```c
void esp_bridge_create_all_netif(void)
{
    ESP_LOGI(TAG, "esp-iot-bridge version: %d.%d.%d", IOT_BRIDGE_VER_MAJOR, IOT_BRIDGE_VER_MINOR, IOT_BRIDGE_VER_PATCH);
    
    // 验证配置
    esp_bridge_validate_config();
    
    // ... 创建网络接口 ...
}
```

### 7.3 检验步骤
1. **配置验证**：
   - 检查`sdkconfig`文件中`CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN`是否为`y`
   - 检查`CONFIG_BRIDGE_DATA_FORWARDING_NETIF_ETHERNET`是否为`y`

2. **卡1自动切换测试**：
   - 将卡1连接到路由器
   - 验证卡1自动变为WAN角色
   - 观察日志，应该看到"W5500 Card1 Got IP (WAN)"
   - 断开路由器，将下位设备连接到卡1
   - 验证卡1自动变为LAN角色
   - 观察日志，应该看到"W5500 Card1 Assigned IP (LAN)"

3. **卡2固定LAN测试**：
   - 连接卡2
   - 验证卡2始终为LAN角色
   - 观察日志，应该看到"W5500 Card2 IP"（固定LAN）
   - 验证卡2不会因为网络状态变化而改变角色

4. **IP地址池验证**：
   - 验证卡1作为LAN时的IP地址池（例如192.168.3.x）
   - 验证卡2的IP地址池（例如192.168.4.x）
   - 确保两个地址池不冲突

5. **代码验证**：
   - 搜索代码中`CONFIG_BRIDGE_NETIF_ETHERNET_AUTO_WAN_OR_LAN`的使用
   - 确保卡1使用自动切换逻辑
   - 确保卡2不使用自动切换逻辑

---

## 步骤8：集成测试和优化

### 8.1 功能测试清单

#### 8.1.1 基础功能测试
- [ ] 4G转WiFi功能正常
- [ ] 卡1作为WAN，可以连接上级路由器
- [ ] 卡2作为LAN，可以为下位计算机分配IP
- [ ] 下位计算机可以通过卡2上网

#### 8.1.2 路由切换测试
- [ ] 卡1连接时，流量优先走卡1
- [ ] 卡1断开时，流量自动切换到4G
- [ ] 卡1重新连接时，流量自动切回卡1
- [ ] 切换过程中数据包不丢失（或丢失最少）

#### 8.1.3 稳定性测试
- [ ] 长时间运行（24小时）无异常
- [ ] 频繁插拔网线（100次）无异常
- [ ] 多设备连接测试（5台设备）正常
- [ ] 高负载测试（持续下载）正常

#### 8.1.4 异常场景测试
- [ ] 卡1和4G同时断开
- [ ] 卡1连接但无互联网访问
- [ ] 卡2连接多台设备
- [ ] 系统重启后配置保持

### 8.2 性能优化

1. **路由切换优化**：
   - 减少切换延迟时间
   - 优化路由表更新速度

2. **内存优化**：
   - 检查内存使用情况
   - 优化缓冲区大小

3. **CPU优化**：
   - 检查CPU使用率
   - 优化任务优先级

### 8.3 日志和调试

1. **添加详细日志**：
   - 网络状态变化日志
   - 路由切换日志
   - 错误和警告日志

2. **调试工具**：
   - 网络状态查询命令
   - 路由表查看命令
   - 性能统计命令

### 8.4 检验步骤

1. **运行完整测试套件**：
   ```bash
   # 编译和烧录
   idf.py build flash
   
   # 运行测试
   # 按照测试清单逐项测试
   ```

2. **收集日志**：
   - 保存测试过程中的所有日志
   - 分析错误和警告信息

3. **性能测试**：
   - 测量路由切换时间
   - 测量网络吞吐量
   - 测量内存和CPU使用率

4. **稳定性测试**：
   - 长时间运行测试
   - 压力测试
   - 异常场景测试

---

## 总结

以上是双W5500功能实施的详细步骤。每个步骤都包含了具体的实现内容、代码修改点和检验方法。建议按照步骤顺序逐一实施，每完成一个步骤都要进行充分的测试，确保功能正常后再进行下一步。

在实施过程中，如果遇到问题，可以参考：
1. ESP-IDF官方文档
2. ESP-IoT-Bridge组件文档
3. W5500芯片手册
4. 项目现有的代码和日志

祝实施顺利！

